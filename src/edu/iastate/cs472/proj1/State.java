package edu.iastate.cs472.proj1;

import java.io.BufferedReader;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.util.Scanner;

/**
 *  
 * @author Andrew McMahon
 *
 */


/**
 * This class represents a board configuration in the 8-puzzle.  Only the initial configuration is 
 * generated by a constructor, while intermediate configurations will be generated via calling
 * the method successorState().  State objects will form two circular doubly-linked lists OPEN and 
 * CLOSED, which will be used by the A* algorithm to search for a path from a given initial board
 * configuration to the final board configuration below: 
 * 
 *  1 2 3 
 *  8   4
 *  7 6 5
 *
 * The final configuration (i.e., the goal state) above is not explicitly represented as an object 
 * of the State class. 
 */

public class State implements Cloneable, Comparable<State>{
	public int[][] board; 		// configuration of tiles 
	
	public State previous;    	// previous node on the OPEN/CLOSED list
	public State next; 			// next node on the OPEN/CLOSED list
	public State predecessor; 	// predecessor node on the path from the initial state 
	
	public Move move;           // the move that generated this state from its predecessor
	public int numMoves; 	    // number of moves from the initial state to this state

	public static Heuristic heu; // heuristic used. shared by all the states. 
	
	private int numMismatchedTiles = -1;    // number of mismatched tiles between this state 
	                                        // and the goal state; negative if not computed yet.
	private int ManhattanDistance = -1;     // Manhattan distance between this state and the 
	                                        // goal state; negative if not computed yet. 
	private int numSingleDoubleMoves = -1;  // number of single and double moves with each double 
										    // move counted as one; negative if not computed yet. 
	/**
	 * used for ease of access for state comparison to goal state
	 */
	private static final int[][] goalState = {{1, 2, 3}, {8, 0, 4}, {7, 6, 5}};


	
	/**
	 * Constructor (for the initial state).  
	 * 
	 * It takes a 2-dimensional array representing an initial board configuration. The empty 
	 * square is represented by the number 0.  
	 * 
	 *     a) Initialize all three links previous, next, and predecessor to null.  
	 *     b) Set move to null and numMoves to zero.
	 * 
	 * @param board
	 * @throws IllegalArgumentException		if board is not a 3X3 array or its nine entries are 
	 * 										not respectively the digits 0, 1, ..., 8. 
	 */
    public State(int[][] board) throws IllegalArgumentException{
    	previous = null;
    	next = null;
    	predecessor = null;
    	move = null;
    	numMoves = 0;
	}
    
    
    /**
     * Constructor (for the initial state) 
     * 
     * It takes a state from an input file that has three rows, each containing three digits 
     * separated by exactly one blank.  Every row starts with a digit. The nine digits are 
     * from 0 to 8 with no duplicates.  
     * 
     * Do the same initializations as for the first constructor. 
     * 
     * @param inputFileName
     * @throws FileNotFoundException
     * @throws IllegalArgumentException  if the file content does not meet the above requirements. 
     */
    public State (String inputFileName) throws FileNotFoundException, IllegalArgumentException{
    	previous = null;
    	next = null;
    	predecessor = null;
    	move = null;
    	numMoves = 0;
		BufferedReader br = new BufferedReader(new FileReader(inputFileName));
		board = new int[3][3];
		try{
			for(int i = 0; i < 3; i++){
				String newRow = br.readLine();
				Scanner newCol = new Scanner(newRow);
				for (int j = 0; j < 3; j++){
					board[i][j] = newCol.nextInt();
				}
			}
		}
		catch(IOException e){
				e.printStackTrace();
		}
	}
    
    
    /**
     * Generate the successor state resulting from a given move.  Throw an exception if the move 
     * cannot be executed.  Besides setting the array board[][] properly, you also need to do the 
     * following:
     * 
     *     a) set the predecessor of the successor state to this state;
     *     b) set the private instance variable move of the successor state to the parameter m; 
     *     c) Set the links next and previous to null;  
     *     d) Set the variable numMoves for the successor state to this.numMoves + 1. 
     * 
     * @param m  one of the moves LEFT, RIGHT, UP, DOWN, DBL_LEFT, DBL_RIGHT, DBL_UP, and DBL_DOWN
     * @return null  			if the successor state is this.predecessor
     *         successor state  otherwise 
     * @throws IllegalArgumentException if LEFT when the empty square is in the right column, or  
     *                                  if RIGHT when the empty square is in the left column, or
     *                                  if UP when the empty square is in the bottom row, or 
     *                                  if DOWN when the empty square is in the top row, or
     *                                  if DBL_LEFT when the empty square is not in the left column, or 
     *                                  if DBL_RIGHT when the empty square is not in the right column, or 
     *                                  if DBL_UP when the empty square is not in the top row, or 
     *                                  if DBL_DOWN when the empty square is not in the bottom row. 
     */                                  
    public State successorState(Move m) throws IllegalArgumentException{
    	//deep copy
        int[][] newBoard = new int[board.length][];
        for(int i = 0; i < board.length; i++){
            newBoard[i] = board[i].clone();
        }
        
        int zeroRow = -1;
        int zeroCol = -1;
        for(int i = 0; i < newBoard.length; i++){
            for(int j = 0; j < newBoard[i].length; j++){
                if(newBoard[i][j] == 0){
                    zeroRow = i;
                    zeroCol = j;
                    break;
                }
            }
        }
        switch(m){
            case LEFT:
                if(zeroCol == 0){
                	throw new IllegalArgumentException("Invalid move: LEFT");
                }
                //swap the empty space with the tile to the left
                newBoard[zeroRow][zeroCol] = newBoard[zeroRow][zeroCol - 1];
                newBoard[zeroRow][zeroCol - 1] = 0;
                break;

            case RIGHT:
                if(zeroCol == newBoard[zeroRow].length - 1){
                	throw new IllegalArgumentException("Invalid move: RIGHT");
                }
                //swap the empty space with the tile to the right
                newBoard[zeroRow][zeroCol] = newBoard[zeroRow][zeroCol + 1];
                newBoard[zeroRow][zeroCol + 1] = 0;
                break;

            case UP:
                if(zeroRow == 0){
                	throw new IllegalArgumentException("Invalid move: UP");
                }
                //swap the empty space with the tile above
                newBoard[zeroRow][zeroCol] = newBoard[zeroRow - 1][zeroCol];
                newBoard[zeroRow - 1][zeroCol] = 0;
                break;

            case DOWN:
                if(zeroRow == newBoard.length - 1){
                	throw new IllegalArgumentException("Invalid move: DOWN");
                }
                //swap the empty space with the tile below
                newBoard[zeroRow][zeroCol] = newBoard[zeroRow + 1][zeroCol];
                newBoard[zeroRow + 1][zeroCol] = 0;
                break;

            case DBL_LEFT:
                if(zeroCol < 2){
                	throw new IllegalArgumentException("Invalid move: DBL_LEFT");
                }
                //swap with the tile to the left twice
                newBoard[zeroRow][zeroCol] = newBoard[zeroRow][zeroCol - 2];
                newBoard[zeroRow][zeroCol - 2] = 0;
                break;

            case DBL_RIGHT:
                if(zeroCol > newBoard[zeroRow].length - 3){
                	throw new IllegalArgumentException("Invalid move: DBL_RIGHT");
                }
                //swap with the tile to the right twice
                newBoard[zeroRow][zeroCol] = newBoard[zeroRow][zeroCol + 2];
                newBoard[zeroRow][zeroCol + 2] = 0;
                break;

            case DBL_UP:
                if(zeroRow < 2){
                	throw new IllegalArgumentException("Invalid move: DBL_UP");
                }
                //swap with the tile above twice
                newBoard[zeroRow][zeroCol] = newBoard[zeroRow - 2][zeroCol];
                newBoard[zeroRow - 2][zeroCol] = 0;
                break;

            case DBL_DOWN:
                if(zeroRow > newBoard.length - 3){
                	throw new IllegalArgumentException("Invalid move: DBL_DOWN");
                }
                //swap with the tile below twice
                newBoard[zeroRow][zeroCol] = newBoard[zeroRow + 2][zeroCol];
                newBoard[zeroRow + 2][zeroCol] = 0;
                break;

            default:
                throw new IllegalArgumentException("Unknown move");
        }
        
        State successor = new State(newBoard);   
        successor.previous = this; 
        successor.move = m;      
        successor.next = null; 
        successor.previous = null;
        successor.numMoves = this.numMoves + 1;

        return successor;
    }
    
        
    /**
     * Determines if the board configuration in this state can be rearranged into the goal configuration. 
     * According to the PowerPoint notes that introduce the 8-puzzle, we check if this state has an odd number 
     * of inversions. 
     * 
     * @return true if the puzzle starting in this state can be rearranged into the goal state.
     */
    public boolean solvable(){
    	int[] board1D = this.to1D();
        int inversions = 0;

        //count inversions
        for(int i = 0; i < board1D.length; i++){
            for(int j = i + 1; j < board1D.length; j++){
                if(board1D[i] > board1D[j] && board1D[i] != 0 && board1D[j] != 0){
                    inversions++;
                }
            }
        }
        
        //from the powerpoint, if the num of inversions is odd, it is not returnable (return false)
        if(inversions == 0) {
        	return true;
        }
        
        return (inversions % 2 == 0);
    }
    
    
    /**
     * Check if this state is the goal state, namely, if the array board[][] stores the following contents: 
     * 
     * 		1 2 3 
     * 		8 0 4 
     * 		7 6 5 
     * 
     * @return
     */
    public boolean isGoalState(){
    	if(board[0][0] == 1 && board[0][1] == 2 && board[0][2] == 3 && board[1][0] == 8 && board[1][1] == 0 && board[1][2] == 4 && board[2][0] == 7 && board[2][1] == 6 && board[2][2] == 5){
    		return true;
    	}
    	return false; 
    }
    
    
    /**
     * Write the board configuration according to the following format:
     * 
     *     a) Output row by row in three lines with no indentations.  
     *     b) Two adjacent tiles in each row have exactly one blank in between. 
     *     c) The empty square is represented by a blank.  
     *     
     * For example, 
     * 
     * 2   3
     * 1 8 4
     * 7 6 5  
     * 
     */
    @Override 
    public String toString(){
    	String returner = "";
    	for(int i = 0; i < 3; i++){
    		for(int j = 0; j < 3; j++){
    	    	if(board[i][j] == 0){
    	    		returner += "  ";
    	    		if(j == 2) {
    	    			returner += "\n";
    	    		}
    	    	}
    	    	else{
    	    		if(j == 3){
    	    			returner += board[i][j] + "\n";
    	    		}
    	    		else{
    	    			returner += board[i][j] + " ";
    	    		}

    	    	}
    		}
    	}
    	return returner;
    }
    
    
    /**
     * Create a clone of this State object by copying over the board[][]. Set the links previous,
     * next, and predecessor to null. 
     * 
     * The method is called by SuccessorState(); 
     */
    @Override
    public Object clone(){
    	State copy = new State(new int[3][3]);
    	for(int i = 0; i < 3; i++){
    		for(int j = 0; j < 3; j ++){
    			copy.board[i][j] = this.board[i][j];
    		}
    	}
    	//technically don't need as constructor already has this
    	copy.previous = null;
    	copy.next = null;
    	copy.predecessor = null;
    	return copy; 
    }
  

    /**
     * Compare this state with the argument state.  Two states are equal if their arrays board[][] 
     * have the same content.
     */
    @Override 
    public boolean equals(Object o){
        if (o == null){
            return false;
        }
        if (o.getClass() != this.getClass()){
            return false;
        }
        State s = (State) o;
    	for(int i = 0; i < 3; i++){
    		for(int j = 0; j < 3; j++) {
    			if(board[i][j] != s.board[i][j]){
    				return false;
    			}
    		}
    	}
    	return true; 
    }
        
    
    /**
     * Evaluate the cost of this state as the sum of the number of moves from the initial state and 
     * the estimated number of moves to the goal state using the heuristic stored in the instance 
     * variable heu. 
     * 
     * If heu == TileMismatch, add up numMoves and the return values from computeNumMismatchedTiles().
     * If heu == MahattanDist, add up numMoves and the return values of computeMahattanDistance(). 
     * If heu == DoubleMoveHeuristic, add up numMoves and the return value of computeNumSingleDoubleMoves(). 
     * 
     * @return estimated number of moves from the initial state to the goal state via this state.
     * @throws IllegalArgumentException if heuristic is none of TileMismatch, MahattanDist, DoubleMoveHeuristic. 
     */
    public int cost() throws IllegalArgumentException{
    	int h = 0;
    	if(heu == Heuristic.TileMismatch){
    		h = computeNumMismatchedTiles();
    	}
    	else if(heu == Heuristic.ManhattanDist){  		
    		h = computeManhattanDistance();
    	}
    	else if(heu == Heuristic.DoubleMoveHeuristic){   		
    		h  = computeNumSingleDoubleMoves();
    	}	
    	else{
    		throw new IllegalArgumentException();
    	}
    	return this.numMoves + h;
	}
    
    /**
     * Compare two states by the cost. Let c1 and c2 be the costs of this state and the argument state s.
     * 
     * @return -1 if c1 < c2 
     *          0 if c1 = c2 
     *          1 if c1 > c2 
     *          
     * Call the method cost(). This comparison will be used in maintaining the OPEN list by the A* algorithm.
     */
    @Override
    public int compareTo(State s){
    	if(this.cost() < s.cost()){
    		return -1;
    	}
    	else if(this.cost() > s.cost()){
    		return 1;
    	}
    	else{
    		return 0;
    	}
    }
    

    /**
     * Return the value of the private variable numMismatchedTiles if it is non-negative, and compute its 
     * value otherwise. 
     * 
     * @return the number of mismatched tiles between this state and the goal state. 
     */
	private int computeNumMismatchedTiles(){
		if(this.numMismatchedTiles >= 0){
			return this.numMismatchedTiles;
		}
		else{
			this.numMismatchedTiles = 0;
		    for(int i = 0; i < 3; i++){
		        for(int j = 0; j < 3; j++){
		            if(this.board[i][j] != goalState[i][j] && this.board[i][j] != 0){
		            	numMismatchedTiles++;
		            }
		        }
		    }
		    return numMismatchedTiles;
		}
	}
	
	/**
	 * Return the value of the private variable ManhattanDistance if it is non-negative, and compute its value 
	 * otherwise.
	 * 
	 * @return the Manhattan distance between this state and the goal state. 
	 */
	private int computeManhattanDistance(){
		if(ManhattanDistance >= 0){
			return this.ManhattanDistance;
		}
		else{
		 this.ManhattanDistance = 0;
		    for(int i = 0; i < 3; i++){
		        for(int j = 0; j < 3; j++){
		            int tile = this.board[i][j];
		            if(tile != 0){
		                for(int x = 0; x < 3; x++){
		                    for(int y = 0; y < 3; y++){
		                        if(goalState[x][y] == tile){
		                            this.ManhattanDistance += Math.abs(i - x) + Math.abs(j - y);
		                        }
		                    }
		                }
		            }
		        }
		    }
		    return this.ManhattanDistance;
		}
	}
	
	
	/**
	 * Return the value of the private variable numSingleDoubleMoves if it is non-negative, and compute its value 
	 * otherwise. 
	 * 
	 * @return the value of the private variable numSingleDoubleMoves that bounds from below the number of moves, 
	 *         single or double, which will take this state to the goal state.
	 */
	private int computeNumSingleDoubleMoves(){
		// TODO 
		if(numSingleDoubleMoves >= 0){
			return numSingleDoubleMoves;
		}
	    int singleMoves = 0;
	    int doubleMoves = 0;

	    //check positions of numbers in the current board compared to the goal state
	    for(int row = 0; row < 3; row++){
	        for(int col = 0; col < 3; col++){
	            int value = board[row][col];
	            if(value == 0){
	            	//skip the space
	            	continue;
	            }
	            
	            //find where this value should be in the goal state
	            int goalRow = (value - 1) / 3;
	            int goalCol = (value - 1) % 3;

	            int distance = Math.abs(goalRow - row) + Math.abs(goalCol - col);
	            singleMoves += distance;

	            //check for possible double moves
	            if (distance >= 2) {
	                doubleMoves++;
	            }
	        }
	    }

	    //total moves is sum of single and double moves
	    numSingleDoubleMoves = singleMoves + doubleMoves;
	    return numSingleDoubleMoves;
	}
	
	/**
	 * Given an input of a 3x3 2D array, make a 9x1 1D array (flatten it)
	 * 
	 * @return 1D array of all tiles from the inputted 2D array
	 */
	private int[] to1D(){
	    int[] arr1D = new int[9];
	    int index = 0;
	    for (int i = 0; i < 3; i++) {
	        for (int j = 0; j < 3; j++) {
	        	arr1D[index] = board[i][j];
	            index++;
	        }
	    }
	    return arr1D;
	}
}
